{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"vodscrepe \u00b6 Description \u00b6 This PyPI package is best described as a tool for scraping the vods.co website. Currently, the package only supports Super Smash Bros. Melee vods. Installation \u00b6 With Python installed, simply run the following command to add the package to your project. 1 python -m pip install vodscrepe Usage \u00b6 The following is an example usage of the package, which is also included in the repo as example.py : 1 2 3 4 5 6 7 8 9 10 11 from tqdm import tqdm from vodscrepe import Scraper s = Scraper ( 'melee' ) try : for vod in s . scrape ( show_progress = True ): tqdm . write ( str ( vod )) except KeyboardInterrupt : tqdm . write ( \"Scraping terminated.\" ) This example lists information about the vods from the most recent to the last page in the following fashion: 1 python example.py > sets.txt Then, the sets.txt file becomes populated with vod information... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ['2020-03-15'] CEO Dreamland 2020 - Colbol (Fox) vs Hungrybox (Jigglypuff) - Grand Finals - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Colbol (Fox) vs n0ne (Captain Falcon) - Losers Finals - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Colbol (Fox) vs Gahtzu (Captain Falcon) - Losers Semis - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Hungrybox (Jigglypuff) vs n0ne (Captain Falcon) - Winners Finals - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Panda (FL) (Fox) vs Gahtzu (Captain Falcon) - Losers Quarters - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Colbol (Fox) vs Chef Rach (Captain Falcon) - Losers Quarters - Bo5 ['2020-03-15'] CEO Dreamland 2020 - n0ne (Captain Falcon) vs Panda (FL) (Fox) - Winners Semis - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Colbol (Fox) vs Hungrybox (Jigglypuff) - Winners Semis - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Krudo (Sheik) vs Gahtzu (Captain Falcon) - Losers Top 8 - Bo5 ['2020-03-15'] CEO Dreamland 2020 - blankshooter744 (Fox) vs Chef Rach (Captain Falcon) - Losers Round 5 - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Leighton (Jigglypuff) vs Prof (Marth) - Losers Round 5 - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Sinbad (Sheik) vs Krudo (Sheik) - Losers Round 5 - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Wevans (Samus) vs Gahtzu (Captain Falcon) - Losers Round 5 - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Sinbad (Sheik) vs Dom (FL) (Marth) - Losers Round 4 - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Colbol (Fox) vs Gahtzu (Captain Falcon) - Winners Quarters - Bo5 Scraping terminated. ...while the terminal details the progress: 1 2 All vods: 0 % | | 0 /331 [ 00 :07<?, ?pages/s ] Page 0 : 25 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 15 /60 [ 00 :07< 00 :12, 3 .07vods/s ] Feel free to check out the docs for more information. License \u00b6 This software is released under the terms of MIT license .","title":"Overview"},{"location":"#vodscrepe","text":"","title":"vodscrepe"},{"location":"#description","text":"This PyPI package is best described as a tool for scraping the vods.co website. Currently, the package only supports Super Smash Bros. Melee vods.","title":"Description"},{"location":"#installation","text":"With Python installed, simply run the following command to add the package to your project. 1 python -m pip install vodscrepe","title":"Installation"},{"location":"#usage","text":"The following is an example usage of the package, which is also included in the repo as example.py : 1 2 3 4 5 6 7 8 9 10 11 from tqdm import tqdm from vodscrepe import Scraper s = Scraper ( 'melee' ) try : for vod in s . scrape ( show_progress = True ): tqdm . write ( str ( vod )) except KeyboardInterrupt : tqdm . write ( \"Scraping terminated.\" ) This example lists information about the vods from the most recent to the last page in the following fashion: 1 python example.py > sets.txt Then, the sets.txt file becomes populated with vod information... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ['2020-03-15'] CEO Dreamland 2020 - Colbol (Fox) vs Hungrybox (Jigglypuff) - Grand Finals - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Colbol (Fox) vs n0ne (Captain Falcon) - Losers Finals - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Colbol (Fox) vs Gahtzu (Captain Falcon) - Losers Semis - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Hungrybox (Jigglypuff) vs n0ne (Captain Falcon) - Winners Finals - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Panda (FL) (Fox) vs Gahtzu (Captain Falcon) - Losers Quarters - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Colbol (Fox) vs Chef Rach (Captain Falcon) - Losers Quarters - Bo5 ['2020-03-15'] CEO Dreamland 2020 - n0ne (Captain Falcon) vs Panda (FL) (Fox) - Winners Semis - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Colbol (Fox) vs Hungrybox (Jigglypuff) - Winners Semis - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Krudo (Sheik) vs Gahtzu (Captain Falcon) - Losers Top 8 - Bo5 ['2020-03-15'] CEO Dreamland 2020 - blankshooter744 (Fox) vs Chef Rach (Captain Falcon) - Losers Round 5 - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Leighton (Jigglypuff) vs Prof (Marth) - Losers Round 5 - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Sinbad (Sheik) vs Krudo (Sheik) - Losers Round 5 - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Wevans (Samus) vs Gahtzu (Captain Falcon) - Losers Round 5 - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Sinbad (Sheik) vs Dom (FL) (Marth) - Losers Round 4 - Bo5 ['2020-03-15'] CEO Dreamland 2020 - Colbol (Fox) vs Gahtzu (Captain Falcon) - Winners Quarters - Bo5 Scraping terminated. ...while the terminal details the progress: 1 2 All vods: 0 % | | 0 /331 [ 00 :07<?, ?pages/s ] Page 0 : 25 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 15 /60 [ 00 :07< 00 :12, 3 .07vods/s ] Feel free to check out the docs for more information.","title":"Usage"},{"location":"#license","text":"This software is released under the terms of MIT license .","title":"License"},{"location":"reference/vodscrepe/","text":"Module vodscrepe \u00b6 None None View Source from .scrape import Scraper __all__ = [ \"Scraper\" ] Sub-modules \u00b6 vodscrepe.aliases vodscrepe.errors vodscrepe.scrape vodscrepe.vod Classes \u00b6 Scraper \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 class Scraper ( video_game : 'str' , event : 'str' = '' , player1 : 'str' = '' , player2 : 'str' = '' , character1 : 'str' = '' , character2 : 'str' = '' , caster1 : 'str' = '' , caster2 : 'str' = '' , num_workers : 'int' = 10 , num_page_workers : 'int' = 2 , verbose : 'bool' = False ) View Source class Scraper : __ slots__ = \"base_url\" , \"num_workers\" , \"num_page_workers\" , \"session\" , \"num_pages\" , \"verbose\" base_url: URL num_workers: int num_page_workers: int session : FuturesSession num_pages: int verbose : bool def __ init__ ( self , video_game: str , event : str = \"\" , player1: str = \"\" , player2: str = \"\" , character1: str = \"\" , character2: str = \"\" , caster1: str = \"\" , caster2: str = \"\" , num_workers: int = 10 , num_page_workers: int = 2 , verbose : bool = False , ) : self . base_url = self . URL ( video_game , event , player1 , player2 , character1 , character2 , caster1 , caster2 ) self . num_workers = num_workers self . num_page_workers = min ( num_page_workers , self . num_workers ) self . session = FuturesSession ( max_workers = self . num_workers ) page_content = self . request ( str ( self . base_url )). result (). content page_soup = BeautifulSoup ( page_content , \"lxml\" ) self . num_pages = 1 last_page_tag = page_soup . findChild ( \"a\" , title= \"Go to last page\" ) if last_page_tag: self . num_pages = int ( re . search ( r \" page= ([ \\d ] + ) \", last_page_tag[\" href \"]).group(1)) self.verbose = verbose def request(self, url: str) -> Future: return self.session.get(url, headers={\" Accept - Encoding \": \" gzip \"}) def scrape_vod_page(self, vod_id: str, vod_request: Future) -> Tuple[List[str], List[Vod.Caster]]: vod_content = vod_request.result().content vod_strainer = SoupStrainer(\" div \", class_=\" region - inner clearfix \") vod_soup = BeautifulSoup(vod_content, \" lxml \", parse_only=vod_strainer) content = vod_soup.findChild(recursive=False) try: video_ids = [ re.search(r\" ^ ([ ^? ] * ) \", v[\" data - vod \"]).group(1) for v in content.findChildren(\" div \", class_=\" js - video widescreen \", recursive=False) ] if len(video_ids) == 0: raise InvalidVideoError(vod_id) casters = [] casters_tag = content.findChild(\" div \", class_=\" field - items \") if casters_tag: casters = [Vod.Caster(c.getText()) for c in casters_tag.findChildren(recursive=False)] return (video_ids, casters) except KeyError: raise InvalidVideoError(vod_id) def scrape_page(self, page_request: Future) -> Generator[Vod, None, None]: page_content = page_request.result().content page_strainer = SoupStrainer(\" table \") page_soup = BeautifulSoup(page_content, \" lxml \", parse_only=page_strainer) vod_requests = [self.request(tr.findChild(\" a \")[\" href \"]) for tr in page_soup.findChildren(\" tr \")] for table in page_soup.findChildren(recursive=False): date = table.caption.span.getText() for i, row in enumerate(table.tbody.findChildren(recursive=False)): cells = row.findChildren(recursive=False) try: vod_id = re.search(r\" . *\\/ (. * ) \", cells[1].a[\" href \"]).group(1) try: best_of = int(re.search(r\" Bo ([ \\d ] * ) \", cells[3].getText()).group(1)) except AttributeError: continue players = [] player = Vod.Player(\" Unknown \", []) for tag in cells[1].a.span.findChildren(recursive=False): if tag.name == \" b \": if len(player.characters) != 0: players.append(player) player = Vod.Player(\" Unknown \", []) player.alias = tag.getText() elif tag.name == \" img \": player.characters.append(guess_character(tag[\" src \"][24:-4])) players.append(player) video_ids, casters = self.scrape_vod_page(vod_id, vod_requests[i]) tournament = re.search(r\" [ ^\\s ]. * [ ^\\s ] \", cells[0].getText()).group() _round = re.search(r\" [ ^\\s ]. * [ ^\\s ] \", cells[4].getText()).group() yield Vod(vod_id, video_ids, date, tournament, players, casters, _round, best_of) except InvalidVideoError as e: if self.verbose: print(e, file=sys.stderr) def scrape(self, pages: Sequence[int] = [], show_progress: bool = False) -> Generator[Vod, None, None]: if not pages: pages = range(self.num_pages - 1) self.num_page_workers = min(self.num_page_workers, len(pages)) request_queue: Queue[Future] = Queue(self.num_page_workers) for i in range(self.num_page_workers): request_queue.put(self.request(f\" { self . base_url } ?page= { pages [ i ]} \")) if show_progress: pages = tqdm(pages, position=1, unit=\" pages \", desc=\" All vods \") for page in pages: vods = self.scrape_page(request_queue.get()) if show_progress: vods = tqdm(vods, position=0, unit=\" vods \", desc=f\" Page { page } \", total=60) for vod in vods: yield vod request_queue.put(self.request(f\" { self . base_url } ?page= { page + self . num_page_workers } \")) @dataclass class URL: video_game: str event: str = \"\" player1: str = \"\" player2: str = \"\" character1: str = \"\" character2: str = \"\" caster1: str = \"\" caster2: str = \"\" def __str__(self) -> str: url = \" https : // vods . co/ \" + self.video_game if self.player1: url += \" / player/ \" + self.player1 if self.player2: url += \" / player2/ \" + self.player2 if self.event: url += \" / event/ \" + self.event if self.character1: url += \" / character/ \" + self.character1 if self.character2: url += \" / character2/ \" + self.character2 if self.caster1: url += \" / caster/ \" + self.character1 if self.caster2: url += \" / caster2/ \" + self . character2 return url Class variables \u00b6 1 URL Instance variables \u00b6 1 base_url 1 num_page_workers 1 num_pages 1 num_workers 1 session 1 verbose Methods \u00b6 request \u00b6 1 2 3 4 def request ( self , url : 'str' ) -> 'Future' View Source def request ( self , url : str ) -> Future : return self . session . get ( url , headers = { \"Accept-Encoding\" : \"gzip\" }) scrape \u00b6 1 2 3 4 5 def scrape ( self , pages : 'Sequence[int]' = [], show_progress : 'bool' = False ) -> 'Generator[Vod, None, None]' View Source def scrape ( self , pages : Sequence [ int ] = [] , show_progress : bool = False ) -> Generator [ Vod, None, None ] : if not pages : pages = range ( self . num_pages - 1 ) self . num_page_workers = min ( self . num_page_workers , len ( pages )) request_queue : Queue [ Future ] = Queue ( self . num_page_workers ) for i in range ( self . num_page_workers ) : request_queue . put ( self . request ( f \"{self.base_url}?page={pages[i]}\" )) if show_progress : pages = tqdm ( pages , position = 1 , unit = \"pages\" , desc = \"All vods\" ) for page in pages : vods = self . scrape_page ( request_queue . get ()) if show_progress : vods = tqdm ( vods , position = 0 , unit = \"vods\" , desc = f \"Page {page}\" , total = 60 ) for vod in vods : yield vod request_queue . put ( self . request ( f \"{self.base_url}?page={page + self.num_page_workers}\" )) scrape_page \u00b6 1 2 3 4 def scrape_page ( self , page_request : 'Future' ) -> 'Generator[Vod, None, None]' View Source def scrape_page ( self , page_request: Future ) -> Generator [ Vod , None , None ] : page_content = page_request . result (). content page_strainer = SoupStrainer ( \"table\" ) page_soup = BeautifulSoup ( page_content , \"lxml\" , parse_only = page_strainer ) vod_requests = [ self . request ( tr . findChild ( \"a\" )[ \"href\" ]) for tr in page_soup . findChildren ( \"tr\" )] for table in page_soup . findChildren ( recursive = False ) : date = table . caption . span . getText () for i , row in enumerate ( table . tbody . findChildren ( recursive = False )) : cells = row . findChildren ( recursive = False ) try : vod_id = re . search ( r \" . *\\/ (. * ) \", cells[1].a[\" href \"]).group(1) try: best_of = int(re.search(r\" Bo ([ \\d ] * ) \", cells[3].getText()).group(1)) except AttributeError: continue players = [] player = Vod.Player(\" Unknown \", []) for tag in cells[1].a.span.findChildren(recursive=False): if tag.name == \" b \": if len(player.characters) != 0: players.append(player) player = Vod.Player(\" Unknown \", []) player.alias = tag.getText() elif tag.name == \" img \": player.characters.append(guess_character(tag[\" src \"][24:-4])) players.append(player) video_ids, casters = self.scrape_vod_page(vod_id, vod_requests[i]) tournament = re.search(r\" [ ^\\s ]. * [ ^\\s ] \", cells[0].getText()).group() _round = re.search(r\" [ ^\\s ]. * [ ^\\s ] \" , cells [ 4 ]. getText ()). group () yield Vod ( vod_id , video_ids , date , tournament , players , casters , _ round , best_of ) except InvalidVideoError as e : if self . verbose : print ( e , file = sys . stderr ) scrape_vod_page \u00b6 1 2 3 4 5 def scrape_vod_page ( self , vod_id : 'str' , vod_request : 'Future' ) -> 'Tuple[List[str], List[Vod.Caster]]' View Source def scrape_vod_page ( self , vod_id : str , vod_request : Future ) -> Tuple [ List[str ] , List [ Vod.Caster ] ]: vod_content = vod_request . result (). content vod_strainer = SoupStrainer ( \"div\" , class_ = \"region-inner clearfix\" ) vod_soup = BeautifulSoup ( vod_content , \"lxml\" , parse_only = vod_strainer ) content = vod_soup . findChild ( recursive = False ) try : video_ids = [ re.search(r\"^([^? ]* ) \", v[\" data - vod \"]).group(1) for v in content.findChildren(\" div \", class_=\" js - video widescreen \", recursive=False) ] if len(video_ids) == 0: raise InvalidVideoError(vod_id) casters = [] casters_tag = content.findChild(\" div \", class_=\" field - items \" ) if casters_tag : casters = [ Vod.Caster(c.getText()) for c in casters_tag.findChildren(recursive=False) ] return ( video_ids , casters ) except KeyError : raise InvalidVideoError ( vod_id )","title":"Index"},{"location":"reference/vodscrepe/#module-vodscrepe","text":"None None View Source from .scrape import Scraper __all__ = [ \"Scraper\" ]","title":"Module vodscrepe"},{"location":"reference/vodscrepe/#sub-modules","text":"vodscrepe.aliases vodscrepe.errors vodscrepe.scrape vodscrepe.vod","title":"Sub-modules"},{"location":"reference/vodscrepe/#classes","text":"","title":"Classes"},{"location":"reference/vodscrepe/#scraper","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Scraper ( video_game : 'str' , event : 'str' = '' , player1 : 'str' = '' , player2 : 'str' = '' , character1 : 'str' = '' , character2 : 'str' = '' , caster1 : 'str' = '' , caster2 : 'str' = '' , num_workers : 'int' = 10 , num_page_workers : 'int' = 2 , verbose : 'bool' = False ) View Source class Scraper : __ slots__ = \"base_url\" , \"num_workers\" , \"num_page_workers\" , \"session\" , \"num_pages\" , \"verbose\" base_url: URL num_workers: int num_page_workers: int session : FuturesSession num_pages: int verbose : bool def __ init__ ( self , video_game: str , event : str = \"\" , player1: str = \"\" , player2: str = \"\" , character1: str = \"\" , character2: str = \"\" , caster1: str = \"\" , caster2: str = \"\" , num_workers: int = 10 , num_page_workers: int = 2 , verbose : bool = False , ) : self . base_url = self . URL ( video_game , event , player1 , player2 , character1 , character2 , caster1 , caster2 ) self . num_workers = num_workers self . num_page_workers = min ( num_page_workers , self . num_workers ) self . session = FuturesSession ( max_workers = self . num_workers ) page_content = self . request ( str ( self . base_url )). result (). content page_soup = BeautifulSoup ( page_content , \"lxml\" ) self . num_pages = 1 last_page_tag = page_soup . findChild ( \"a\" , title= \"Go to last page\" ) if last_page_tag: self . num_pages = int ( re . search ( r \" page= ([ \\d ] + ) \", last_page_tag[\" href \"]).group(1)) self.verbose = verbose def request(self, url: str) -> Future: return self.session.get(url, headers={\" Accept - Encoding \": \" gzip \"}) def scrape_vod_page(self, vod_id: str, vod_request: Future) -> Tuple[List[str], List[Vod.Caster]]: vod_content = vod_request.result().content vod_strainer = SoupStrainer(\" div \", class_=\" region - inner clearfix \") vod_soup = BeautifulSoup(vod_content, \" lxml \", parse_only=vod_strainer) content = vod_soup.findChild(recursive=False) try: video_ids = [ re.search(r\" ^ ([ ^? ] * ) \", v[\" data - vod \"]).group(1) for v in content.findChildren(\" div \", class_=\" js - video widescreen \", recursive=False) ] if len(video_ids) == 0: raise InvalidVideoError(vod_id) casters = [] casters_tag = content.findChild(\" div \", class_=\" field - items \") if casters_tag: casters = [Vod.Caster(c.getText()) for c in casters_tag.findChildren(recursive=False)] return (video_ids, casters) except KeyError: raise InvalidVideoError(vod_id) def scrape_page(self, page_request: Future) -> Generator[Vod, None, None]: page_content = page_request.result().content page_strainer = SoupStrainer(\" table \") page_soup = BeautifulSoup(page_content, \" lxml \", parse_only=page_strainer) vod_requests = [self.request(tr.findChild(\" a \")[\" href \"]) for tr in page_soup.findChildren(\" tr \")] for table in page_soup.findChildren(recursive=False): date = table.caption.span.getText() for i, row in enumerate(table.tbody.findChildren(recursive=False)): cells = row.findChildren(recursive=False) try: vod_id = re.search(r\" . *\\/ (. * ) \", cells[1].a[\" href \"]).group(1) try: best_of = int(re.search(r\" Bo ([ \\d ] * ) \", cells[3].getText()).group(1)) except AttributeError: continue players = [] player = Vod.Player(\" Unknown \", []) for tag in cells[1].a.span.findChildren(recursive=False): if tag.name == \" b \": if len(player.characters) != 0: players.append(player) player = Vod.Player(\" Unknown \", []) player.alias = tag.getText() elif tag.name == \" img \": player.characters.append(guess_character(tag[\" src \"][24:-4])) players.append(player) video_ids, casters = self.scrape_vod_page(vod_id, vod_requests[i]) tournament = re.search(r\" [ ^\\s ]. * [ ^\\s ] \", cells[0].getText()).group() _round = re.search(r\" [ ^\\s ]. * [ ^\\s ] \", cells[4].getText()).group() yield Vod(vod_id, video_ids, date, tournament, players, casters, _round, best_of) except InvalidVideoError as e: if self.verbose: print(e, file=sys.stderr) def scrape(self, pages: Sequence[int] = [], show_progress: bool = False) -> Generator[Vod, None, None]: if not pages: pages = range(self.num_pages - 1) self.num_page_workers = min(self.num_page_workers, len(pages)) request_queue: Queue[Future] = Queue(self.num_page_workers) for i in range(self.num_page_workers): request_queue.put(self.request(f\" { self . base_url } ?page= { pages [ i ]} \")) if show_progress: pages = tqdm(pages, position=1, unit=\" pages \", desc=\" All vods \") for page in pages: vods = self.scrape_page(request_queue.get()) if show_progress: vods = tqdm(vods, position=0, unit=\" vods \", desc=f\" Page { page } \", total=60) for vod in vods: yield vod request_queue.put(self.request(f\" { self . base_url } ?page= { page + self . num_page_workers } \")) @dataclass class URL: video_game: str event: str = \"\" player1: str = \"\" player2: str = \"\" character1: str = \"\" character2: str = \"\" caster1: str = \"\" caster2: str = \"\" def __str__(self) -> str: url = \" https : // vods . co/ \" + self.video_game if self.player1: url += \" / player/ \" + self.player1 if self.player2: url += \" / player2/ \" + self.player2 if self.event: url += \" / event/ \" + self.event if self.character1: url += \" / character/ \" + self.character1 if self.character2: url += \" / character2/ \" + self.character2 if self.caster1: url += \" / caster/ \" + self.character1 if self.caster2: url += \" / caster2/ \" + self . character2 return url","title":"Scraper"},{"location":"reference/vodscrepe/#class-variables","text":"1 URL","title":"Class variables"},{"location":"reference/vodscrepe/#instance-variables","text":"1 base_url 1 num_page_workers 1 num_pages 1 num_workers 1 session 1 verbose","title":"Instance variables"},{"location":"reference/vodscrepe/#methods","text":"","title":"Methods"},{"location":"reference/vodscrepe/#request","text":"1 2 3 4 def request ( self , url : 'str' ) -> 'Future' View Source def request ( self , url : str ) -> Future : return self . session . get ( url , headers = { \"Accept-Encoding\" : \"gzip\" })","title":"request"},{"location":"reference/vodscrepe/#scrape","text":"1 2 3 4 5 def scrape ( self , pages : 'Sequence[int]' = [], show_progress : 'bool' = False ) -> 'Generator[Vod, None, None]' View Source def scrape ( self , pages : Sequence [ int ] = [] , show_progress : bool = False ) -> Generator [ Vod, None, None ] : if not pages : pages = range ( self . num_pages - 1 ) self . num_page_workers = min ( self . num_page_workers , len ( pages )) request_queue : Queue [ Future ] = Queue ( self . num_page_workers ) for i in range ( self . num_page_workers ) : request_queue . put ( self . request ( f \"{self.base_url}?page={pages[i]}\" )) if show_progress : pages = tqdm ( pages , position = 1 , unit = \"pages\" , desc = \"All vods\" ) for page in pages : vods = self . scrape_page ( request_queue . get ()) if show_progress : vods = tqdm ( vods , position = 0 , unit = \"vods\" , desc = f \"Page {page}\" , total = 60 ) for vod in vods : yield vod request_queue . put ( self . request ( f \"{self.base_url}?page={page + self.num_page_workers}\" ))","title":"scrape"},{"location":"reference/vodscrepe/#scrape_page","text":"1 2 3 4 def scrape_page ( self , page_request : 'Future' ) -> 'Generator[Vod, None, None]' View Source def scrape_page ( self , page_request: Future ) -> Generator [ Vod , None , None ] : page_content = page_request . result (). content page_strainer = SoupStrainer ( \"table\" ) page_soup = BeautifulSoup ( page_content , \"lxml\" , parse_only = page_strainer ) vod_requests = [ self . request ( tr . findChild ( \"a\" )[ \"href\" ]) for tr in page_soup . findChildren ( \"tr\" )] for table in page_soup . findChildren ( recursive = False ) : date = table . caption . span . getText () for i , row in enumerate ( table . tbody . findChildren ( recursive = False )) : cells = row . findChildren ( recursive = False ) try : vod_id = re . search ( r \" . *\\/ (. * ) \", cells[1].a[\" href \"]).group(1) try: best_of = int(re.search(r\" Bo ([ \\d ] * ) \", cells[3].getText()).group(1)) except AttributeError: continue players = [] player = Vod.Player(\" Unknown \", []) for tag in cells[1].a.span.findChildren(recursive=False): if tag.name == \" b \": if len(player.characters) != 0: players.append(player) player = Vod.Player(\" Unknown \", []) player.alias = tag.getText() elif tag.name == \" img \": player.characters.append(guess_character(tag[\" src \"][24:-4])) players.append(player) video_ids, casters = self.scrape_vod_page(vod_id, vod_requests[i]) tournament = re.search(r\" [ ^\\s ]. * [ ^\\s ] \", cells[0].getText()).group() _round = re.search(r\" [ ^\\s ]. * [ ^\\s ] \" , cells [ 4 ]. getText ()). group () yield Vod ( vod_id , video_ids , date , tournament , players , casters , _ round , best_of ) except InvalidVideoError as e : if self . verbose : print ( e , file = sys . stderr )","title":"scrape_page"},{"location":"reference/vodscrepe/#scrape_vod_page","text":"1 2 3 4 5 def scrape_vod_page ( self , vod_id : 'str' , vod_request : 'Future' ) -> 'Tuple[List[str], List[Vod.Caster]]' View Source def scrape_vod_page ( self , vod_id : str , vod_request : Future ) -> Tuple [ List[str ] , List [ Vod.Caster ] ]: vod_content = vod_request . result (). content vod_strainer = SoupStrainer ( \"div\" , class_ = \"region-inner clearfix\" ) vod_soup = BeautifulSoup ( vod_content , \"lxml\" , parse_only = vod_strainer ) content = vod_soup . findChild ( recursive = False ) try : video_ids = [ re.search(r\"^([^? ]* ) \", v[\" data - vod \"]).group(1) for v in content.findChildren(\" div \", class_=\" js - video widescreen \", recursive=False) ] if len(video_ids) == 0: raise InvalidVideoError(vod_id) casters = [] casters_tag = content.findChild(\" div \", class_=\" field - items \" ) if casters_tag : casters = [ Vod.Caster(c.getText()) for c in casters_tag.findChildren(recursive=False) ] return ( video_ids , casters ) except KeyError : raise InvalidVideoError ( vod_id )","title":"scrape_vod_page"},{"location":"reference/vodscrepe/aliases/","text":"Module vodscrepe.aliases \u00b6 None None View Source import re stages = { \"Battlefield\" : re . compile ( r \"battle\" , flags = re . I ), \"Dream Land N64\" : re . compile ( r \"land\" , flags = re . I ), \"Final Destination\" : re . compile ( r \"final|fd\" , flags = re . I ), \"Fountain of Dreams\" : re . compile ( r \"fount|fod\" , flags = re . I ), \"Yoshi's Story\" : re . compile ( r \"yoshi\" , flags = re . I ), \"Pokemon Stadium\" : re . compile ( r \"pokemon|stadium|ps\" , flags = re . I ), } characters = { \"Bowser\" : re . compile ( r \"bowser\" , flags = re . I ), \"Captain Falcon\" : re . compile ( r \"falcon|cf\" , flags = re . I ), \"Donkey Kong\" : re . compile ( r \"donkey|kong|dk\" , flags = re . I ), \"Dr. Mario\" : re . compile ( r \"doc|dr\" , flags = re . I ), \"Falco\" : re . compile ( r \"falco\\b\" , flags = re . I ), \"Fox\" : re . compile ( r \"fox\" , flags = re . I ), \"Ganondorf\" : re . compile ( r \"ganon\" , flags = re . I ), \"Ice Climbers\" : re . compile ( r \"ic\" , flags = re . I ), \"Jigglypuff\" : re . compile ( r \"jig|puff\" , flags = re . I ), \"Kirby\" : re . compile ( r \"kirby\" , flags = re . I ), \"Link\" : re . compile ( r \"(?!y)link\" , flags = re . I ), \"Luigi\" : re . compile ( r \"luigi\" , flags = re . I ), \"Mario\" : re . compile ( r \"(?!d)mario\" , flags = re . I ), \"Marth\" : re . compile ( r \"marth\" , flags = re . I ), \"Mewtwo\" : re . compile ( r \"mew\" , flags = re . I ), \"Mr. Game & Watch\" : re . compile ( r \"game|&\" , flags = re . I ), \"Ness\" : re . compile ( r \"ness\" , flags = re . I ), \"Peach\" : re . compile ( r \"peach|daisy\" , flags = re . I ), \"Pichu\" : re . compile ( r \"pichu\" , flags = re . I ), \"Pikachu\" : re . compile ( r \"pika\" , flags = re . I ), \"Roy\" : re . compile ( r \"roy\" , flags = re . I ), \"Samus\" : re . compile ( r \"samus\" , flags = re . I ), \"Sheik\" : re . compile ( r \"sh\" , flags = re . I ), \"Young Link\" : re . compile ( r \"y.*link\" , flags = re . I ), \"Yoshi\" : re . compile ( r \"yoshi\" , flags = re . I ), \"Zelda\" : re . compile ( r \"zelda\" , flags = re . I ), } rounds = { \"Winners Quarters\" : re . compile ( r \"winner.*quarter|wq\" , flags = re . I ), \"Winners Semis\" : re . compile ( r \"winner.*semi|ws\" , flags = re . I ), \"Winners Finals\" : re . compile ( r \"winner.*final|wf\" , flags = re . I ), \"Losers Eighths\" : re . compile ( r \"loser.*eight\" , flags = re . I ), \"Losers Quarters\" : re . compile ( r \"loser.*quarter|lq\" , flags = re . I ), \"Losers Semis\" : re . compile ( r \"loser.*semi|ls\" , flags = re . I ), \"Losers Finals\" : re . compile ( r \"loser.*final|lf\" , flags = re . I ), \"Grand Finals\" : re . compile ( r \"grand.*final|gf\" , flags = re . I ), } sponsors = { \"Team Liquid\" : re . compile ( r \"liquid|tl\" , flags = re . I ), \"Alliance\" : re . compile ( r \"\\[A\\]|alliance\" , flags = re . I ), \"Counter Logic Gaming\" : re . compile ( r \"clg|counter.*logic\" , flags = re . I ), \"Cloud 9\" : re . compile ( r \"c9|cloud\" , flags = re . I ), } def guess_character ( ch ): for item , prog in characters . items (): if prog . search ( ch ): return item return None def guess_stage ( s ): for item , prog in stages . items (): if prog . search ( s ): return item return None def guess_round ( r ): for item , prog in rounds . items (): if prog . search ( r ): return item return None def guess_sponsor ( s ): for item , prog in sponsors . items (): if prog . search ( s ): return item return None Variables \u00b6 1 characters 1 rounds 1 sponsors 1 stages Functions \u00b6 guess_character \u00b6 1 2 3 def guess_character ( ch ) View Source def guess_character ( ch ) : for item , prog in characters . items () : if prog . search ( ch ) : return item return None guess_round \u00b6 1 2 3 def guess_round ( r ) View Source def guess_round ( r ) : for item , prog in rounds . items () : if prog . search ( r ) : return item return None guess_sponsor \u00b6 1 2 3 def guess_sponsor ( s ) View Source def guess_sponsor ( s ) : for item , prog in sponsors . items () : if prog . search ( s ) : return item return None guess_stage \u00b6 1 2 3 def guess_stage ( s ) View Source def guess_stage ( s ) : for item , prog in stages . items () : if prog . search ( s ) : return item return None","title":"Aliases"},{"location":"reference/vodscrepe/aliases/#module-vodscrepealiases","text":"None None View Source import re stages = { \"Battlefield\" : re . compile ( r \"battle\" , flags = re . I ), \"Dream Land N64\" : re . compile ( r \"land\" , flags = re . I ), \"Final Destination\" : re . compile ( r \"final|fd\" , flags = re . I ), \"Fountain of Dreams\" : re . compile ( r \"fount|fod\" , flags = re . I ), \"Yoshi's Story\" : re . compile ( r \"yoshi\" , flags = re . I ), \"Pokemon Stadium\" : re . compile ( r \"pokemon|stadium|ps\" , flags = re . I ), } characters = { \"Bowser\" : re . compile ( r \"bowser\" , flags = re . I ), \"Captain Falcon\" : re . compile ( r \"falcon|cf\" , flags = re . I ), \"Donkey Kong\" : re . compile ( r \"donkey|kong|dk\" , flags = re . I ), \"Dr. Mario\" : re . compile ( r \"doc|dr\" , flags = re . I ), \"Falco\" : re . compile ( r \"falco\\b\" , flags = re . I ), \"Fox\" : re . compile ( r \"fox\" , flags = re . I ), \"Ganondorf\" : re . compile ( r \"ganon\" , flags = re . I ), \"Ice Climbers\" : re . compile ( r \"ic\" , flags = re . I ), \"Jigglypuff\" : re . compile ( r \"jig|puff\" , flags = re . I ), \"Kirby\" : re . compile ( r \"kirby\" , flags = re . I ), \"Link\" : re . compile ( r \"(?!y)link\" , flags = re . I ), \"Luigi\" : re . compile ( r \"luigi\" , flags = re . I ), \"Mario\" : re . compile ( r \"(?!d)mario\" , flags = re . I ), \"Marth\" : re . compile ( r \"marth\" , flags = re . I ), \"Mewtwo\" : re . compile ( r \"mew\" , flags = re . I ), \"Mr. Game & Watch\" : re . compile ( r \"game|&\" , flags = re . I ), \"Ness\" : re . compile ( r \"ness\" , flags = re . I ), \"Peach\" : re . compile ( r \"peach|daisy\" , flags = re . I ), \"Pichu\" : re . compile ( r \"pichu\" , flags = re . I ), \"Pikachu\" : re . compile ( r \"pika\" , flags = re . I ), \"Roy\" : re . compile ( r \"roy\" , flags = re . I ), \"Samus\" : re . compile ( r \"samus\" , flags = re . I ), \"Sheik\" : re . compile ( r \"sh\" , flags = re . I ), \"Young Link\" : re . compile ( r \"y.*link\" , flags = re . I ), \"Yoshi\" : re . compile ( r \"yoshi\" , flags = re . I ), \"Zelda\" : re . compile ( r \"zelda\" , flags = re . I ), } rounds = { \"Winners Quarters\" : re . compile ( r \"winner.*quarter|wq\" , flags = re . I ), \"Winners Semis\" : re . compile ( r \"winner.*semi|ws\" , flags = re . I ), \"Winners Finals\" : re . compile ( r \"winner.*final|wf\" , flags = re . I ), \"Losers Eighths\" : re . compile ( r \"loser.*eight\" , flags = re . I ), \"Losers Quarters\" : re . compile ( r \"loser.*quarter|lq\" , flags = re . I ), \"Losers Semis\" : re . compile ( r \"loser.*semi|ls\" , flags = re . I ), \"Losers Finals\" : re . compile ( r \"loser.*final|lf\" , flags = re . I ), \"Grand Finals\" : re . compile ( r \"grand.*final|gf\" , flags = re . I ), } sponsors = { \"Team Liquid\" : re . compile ( r \"liquid|tl\" , flags = re . I ), \"Alliance\" : re . compile ( r \"\\[A\\]|alliance\" , flags = re . I ), \"Counter Logic Gaming\" : re . compile ( r \"clg|counter.*logic\" , flags = re . I ), \"Cloud 9\" : re . compile ( r \"c9|cloud\" , flags = re . I ), } def guess_character ( ch ): for item , prog in characters . items (): if prog . search ( ch ): return item return None def guess_stage ( s ): for item , prog in stages . items (): if prog . search ( s ): return item return None def guess_round ( r ): for item , prog in rounds . items (): if prog . search ( r ): return item return None def guess_sponsor ( s ): for item , prog in sponsors . items (): if prog . search ( s ): return item return None","title":"Module vodscrepe.aliases"},{"location":"reference/vodscrepe/aliases/#variables","text":"1 characters 1 rounds 1 sponsors 1 stages","title":"Variables"},{"location":"reference/vodscrepe/aliases/#functions","text":"","title":"Functions"},{"location":"reference/vodscrepe/aliases/#guess_character","text":"1 2 3 def guess_character ( ch ) View Source def guess_character ( ch ) : for item , prog in characters . items () : if prog . search ( ch ) : return item return None","title":"guess_character"},{"location":"reference/vodscrepe/aliases/#guess_round","text":"1 2 3 def guess_round ( r ) View Source def guess_round ( r ) : for item , prog in rounds . items () : if prog . search ( r ) : return item return None","title":"guess_round"},{"location":"reference/vodscrepe/aliases/#guess_sponsor","text":"1 2 3 def guess_sponsor ( s ) View Source def guess_sponsor ( s ) : for item , prog in sponsors . items () : if prog . search ( s ) : return item return None","title":"guess_sponsor"},{"location":"reference/vodscrepe/aliases/#guess_stage","text":"1 2 3 def guess_stage ( s ) View Source def guess_stage ( s ) : for item , prog in stages . items () : if prog . search ( s ) : return item return None","title":"guess_stage"},{"location":"reference/vodscrepe/errors/","text":"Module vodscrepe.errors \u00b6 None None View Source class Error ( Exception ): message: str class InvalidVideoError ( Error ): def __init__ ( self , vod_id: str ): message = f \"Invalid Video: vods.co vod '{vod_id}' links to invalid video\" super (). __init__ ( message ) class InvalidPageError ( Error ): def __init__ ( self , * args ): message = \"Invalid Page: vods.co game '%s' does not have page '%i'\" % args super (). __init__ ( message ) Classes \u00b6 Error \u00b6 1 2 3 4 5 class Error ( / , * args , ** kwargs ) View Source class Error ( Exception ): message: str Ancestors (in MRO) \u00b6 builtins.Exception builtins.BaseException Descendants \u00b6 vodscrepe.errors.InvalidVideoError vodscrepe.errors.InvalidPageError Class variables \u00b6 1 args Methods \u00b6 with_traceback \u00b6 1 2 3 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. InvalidPageError \u00b6 1 2 3 class InvalidPageError ( * args ) View Source class InvalidPageError ( Error ): def __init__ ( self , * args ): message = \"Invalid Page: vods.co game '%s' does not have page '%i'\" % args super (). __init__ ( message ) Ancestors (in MRO) \u00b6 vodscrepe.errors.Error builtins.Exception builtins.BaseException Class variables \u00b6 1 args Methods \u00b6 with_traceback \u00b6 1 2 3 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. InvalidVideoError \u00b6 1 2 3 class InvalidVideoError ( vod_id : str ) View Source class InvalidVideoError ( Error ): def __init__ ( self , vod_id: str ): message = f \"Invalid Video: vods.co vod '{vod_id}' links to invalid video\" super (). __init__ ( message ) Ancestors (in MRO) \u00b6 vodscrepe.errors.Error builtins.Exception builtins.BaseException Class variables \u00b6 1 args Methods \u00b6 with_traceback \u00b6 1 2 3 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Errors"},{"location":"reference/vodscrepe/errors/#module-vodscrepeerrors","text":"None None View Source class Error ( Exception ): message: str class InvalidVideoError ( Error ): def __init__ ( self , vod_id: str ): message = f \"Invalid Video: vods.co vod '{vod_id}' links to invalid video\" super (). __init__ ( message ) class InvalidPageError ( Error ): def __init__ ( self , * args ): message = \"Invalid Page: vods.co game '%s' does not have page '%i'\" % args super (). __init__ ( message )","title":"Module vodscrepe.errors"},{"location":"reference/vodscrepe/errors/#classes","text":"","title":"Classes"},{"location":"reference/vodscrepe/errors/#error","text":"1 2 3 4 5 class Error ( / , * args , ** kwargs ) View Source class Error ( Exception ): message: str","title":"Error"},{"location":"reference/vodscrepe/errors/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/vodscrepe/errors/#descendants","text":"vodscrepe.errors.InvalidVideoError vodscrepe.errors.InvalidPageError","title":"Descendants"},{"location":"reference/vodscrepe/errors/#class-variables","text":"1 args","title":"Class variables"},{"location":"reference/vodscrepe/errors/#methods","text":"","title":"Methods"},{"location":"reference/vodscrepe/errors/#with_traceback","text":"1 2 3 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/vodscrepe/errors/#invalidpageerror","text":"1 2 3 class InvalidPageError ( * args ) View Source class InvalidPageError ( Error ): def __init__ ( self , * args ): message = \"Invalid Page: vods.co game '%s' does not have page '%i'\" % args super (). __init__ ( message )","title":"InvalidPageError"},{"location":"reference/vodscrepe/errors/#ancestors-in-mro_1","text":"vodscrepe.errors.Error builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/vodscrepe/errors/#class-variables_1","text":"1 args","title":"Class variables"},{"location":"reference/vodscrepe/errors/#methods_1","text":"","title":"Methods"},{"location":"reference/vodscrepe/errors/#with_traceback_1","text":"1 2 3 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/vodscrepe/errors/#invalidvideoerror","text":"1 2 3 class InvalidVideoError ( vod_id : str ) View Source class InvalidVideoError ( Error ): def __init__ ( self , vod_id: str ): message = f \"Invalid Video: vods.co vod '{vod_id}' links to invalid video\" super (). __init__ ( message )","title":"InvalidVideoError"},{"location":"reference/vodscrepe/errors/#ancestors-in-mro_2","text":"vodscrepe.errors.Error builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/vodscrepe/errors/#class-variables_2","text":"1 args","title":"Class variables"},{"location":"reference/vodscrepe/errors/#methods_2","text":"","title":"Methods"},{"location":"reference/vodscrepe/errors/#with_traceback_2","text":"1 2 3 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/vodscrepe/scrape/","text":"Module vodscrepe.scrape \u00b6 None None View Source from __ future__ import annotations import re import sys from concurrent . futures import Future from dataclasses import dataclass from queue import Queue from typing import Generator , List , Sequence , Tuple from bs4 import BeautifulSoup , SoupStrainer from requests_futures . sessions import FuturesSession from tqdm import tqdm from vodscrepe . vod import Vod from . aliases import guess_character from . errors import InvalidVideoError class Scraper : __ slots__ = \"base_url\" , \"num_workers\" , \"num_page_workers\" , \"session\" , \"num_pages\" , \"verbose\" base_url: URL num_workers: int num_page_workers: int session : FuturesSession num_pages: int verbose : bool def __ init__ ( self , video_game: str , event : str = \"\" , player1: str = \"\" , player2: str = \"\" , character1: str = \"\" , character2: str = \"\" , caster1: str = \"\" , caster2: str = \"\" , num_workers: int = 10 , num_page_workers: int = 2 , verbose : bool = False , ) : self . base_url = self . URL ( video_game , event , player1 , player2 , character1 , character2 , caster1 , caster2 ) self . num_workers = num_workers self . num_page_workers = min ( num_page_workers , self . num_workers ) self . session = FuturesSession ( max_workers = self . num_workers ) page_content = self . request ( str ( self . base_url )). result (). content page_soup = BeautifulSoup ( page_content , \"lxml\" ) self . num_pages = 1 last_page_tag = page_soup . findChild ( \"a\" , title= \"Go to last page\" ) if last_page_tag: self . num_pages = int ( re . search ( r \" page= ([ \\d ] + ) \", last_page_tag[\" href \"]).group(1)) self.verbose = verbose def request(self, url: str) -> Future: return self.session.get(url, headers={\" Accept - Encoding \": \" gzip \"}) def scrape_vod_page(self, vod_id: str, vod_request: Future) -> Tuple[List[str], List[Vod.Caster]]: vod_content = vod_request.result().content vod_strainer = SoupStrainer(\" div \", class_=\" region - inner clearfix \") vod_soup = BeautifulSoup(vod_content, \" lxml \", parse_only=vod_strainer) content = vod_soup.findChild(recursive=False) try: video_ids = [ re.search(r\" ^ ([ ^? ] * ) \", v[\" data - vod \"]).group(1) for v in content.findChildren(\" div \", class_=\" js - video widescreen \", recursive=False) ] if len(video_ids) == 0: raise InvalidVideoError(vod_id) casters = [] casters_tag = content.findChild(\" div \", class_=\" field - items \") if casters_tag: casters = [Vod.Caster(c.getText()) for c in casters_tag.findChildren(recursive=False)] return (video_ids, casters) except KeyError: raise InvalidVideoError(vod_id) def scrape_page(self, page_request: Future) -> Generator[Vod, None, None]: page_content = page_request.result().content page_strainer = SoupStrainer(\" table \") page_soup = BeautifulSoup(page_content, \" lxml \", parse_only=page_strainer) vod_requests = [self.request(tr.findChild(\" a \")[\" href \"]) for tr in page_soup.findChildren(\" tr \")] for table in page_soup.findChildren(recursive=False): date = table.caption.span.getText() for i, row in enumerate(table.tbody.findChildren(recursive=False)): cells = row.findChildren(recursive=False) try: vod_id = re.search(r\" . *\\/ (. * ) \", cells[1].a[\" href \"]).group(1) try: best_of = int(re.search(r\" Bo ([ \\d ] * ) \", cells[3].getText()).group(1)) except AttributeError: continue players = [] player = Vod.Player(\" Unknown \", []) for tag in cells[1].a.span.findChildren(recursive=False): if tag.name == \" b \": if len(player.characters) != 0: players.append(player) player = Vod.Player(\" Unknown \", []) player.alias = tag.getText() elif tag.name == \" img \": player.characters.append(guess_character(tag[\" src \"][24:-4])) players.append(player) video_ids, casters = self.scrape_vod_page(vod_id, vod_requests[i]) tournament = re.search(r\" [ ^\\s ]. * [ ^\\s ] \", cells[0].getText()).group() _round = re.search(r\" [ ^\\s ]. * [ ^\\s ] \", cells[4].getText()).group() yield Vod(vod_id, video_ids, date, tournament, players, casters, _round, best_of) except InvalidVideoError as e: if self.verbose: print(e, file=sys.stderr) def scrape(self, pages: Sequence[int] = [], show_progress: bool = False) -> Generator[Vod, None, None]: if not pages: pages = range(self.num_pages - 1) self.num_page_workers = min(self.num_page_workers, len(pages)) request_queue: Queue[Future] = Queue(self.num_page_workers) for i in range(self.num_page_workers): request_queue.put(self.request(f\" { self . base_url } ?page= { pages [ i ]} \")) if show_progress: pages = tqdm(pages, position=1, unit=\" pages \", desc=\" All vods \") for page in pages: vods = self.scrape_page(request_queue.get()) if show_progress: vods = tqdm(vods, position=0, unit=\" vods \", desc=f\" Page { page } \", total=60) for vod in vods: yield vod request_queue.put(self.request(f\" { self . base_url } ?page= { page + self . num_page_workers } \")) @dataclass class URL: video_game: str event: str = \"\" player1: str = \"\" player2: str = \"\" character1: str = \"\" character2: str = \"\" caster1: str = \"\" caster2: str = \"\" def __str__(self) -> str: url = \" https : // vods . co/ \" + self.video_game if self.player1: url += \" / player/ \" + self.player1 if self.player2: url += \" / player2/ \" + self.player2 if self.event: url += \" / event/ \" + self.event if self.character1: url += \" / character/ \" + self.character1 if self.character2: url += \" / character2/ \" + self.character2 if self.caster1: url += \" / caster/ \" + self.character1 if self.caster2: url += \" / caster2/ \" + self . character2 return url Classes \u00b6 Scraper \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 class Scraper ( video_game : 'str' , event : 'str' = '' , player1 : 'str' = '' , player2 : 'str' = '' , character1 : 'str' = '' , character2 : 'str' = '' , caster1 : 'str' = '' , caster2 : 'str' = '' , num_workers : 'int' = 10 , num_page_workers : 'int' = 2 , verbose : 'bool' = False ) View Source class Scraper : __ slots__ = \"base_url\" , \"num_workers\" , \"num_page_workers\" , \"session\" , \"num_pages\" , \"verbose\" base_url: URL num_workers: int num_page_workers: int session : FuturesSession num_pages: int verbose : bool def __ init__ ( self , video_game: str , event : str = \"\" , player1: str = \"\" , player2: str = \"\" , character1: str = \"\" , character2: str = \"\" , caster1: str = \"\" , caster2: str = \"\" , num_workers: int = 10 , num_page_workers: int = 2 , verbose : bool = False , ) : self . base_url = self . URL ( video_game , event , player1 , player2 , character1 , character2 , caster1 , caster2 ) self . num_workers = num_workers self . num_page_workers = min ( num_page_workers , self . num_workers ) self . session = FuturesSession ( max_workers = self . num_workers ) page_content = self . request ( str ( self . base_url )). result (). content page_soup = BeautifulSoup ( page_content , \"lxml\" ) self . num_pages = 1 last_page_tag = page_soup . findChild ( \"a\" , title= \"Go to last page\" ) if last_page_tag: self . num_pages = int ( re . search ( r \" page= ([ \\d ] + ) \", last_page_tag[\" href \"]).group(1)) self.verbose = verbose def request(self, url: str) -> Future: return self.session.get(url, headers={\" Accept - Encoding \": \" gzip \"}) def scrape_vod_page(self, vod_id: str, vod_request: Future) -> Tuple[List[str], List[Vod.Caster]]: vod_content = vod_request.result().content vod_strainer = SoupStrainer(\" div \", class_=\" region - inner clearfix \") vod_soup = BeautifulSoup(vod_content, \" lxml \", parse_only=vod_strainer) content = vod_soup.findChild(recursive=False) try: video_ids = [ re.search(r\" ^ ([ ^? ] * ) \", v[\" data - vod \"]).group(1) for v in content.findChildren(\" div \", class_=\" js - video widescreen \", recursive=False) ] if len(video_ids) == 0: raise InvalidVideoError(vod_id) casters = [] casters_tag = content.findChild(\" div \", class_=\" field - items \") if casters_tag: casters = [Vod.Caster(c.getText()) for c in casters_tag.findChildren(recursive=False)] return (video_ids, casters) except KeyError: raise InvalidVideoError(vod_id) def scrape_page(self, page_request: Future) -> Generator[Vod, None, None]: page_content = page_request.result().content page_strainer = SoupStrainer(\" table \") page_soup = BeautifulSoup(page_content, \" lxml \", parse_only=page_strainer) vod_requests = [self.request(tr.findChild(\" a \")[\" href \"]) for tr in page_soup.findChildren(\" tr \")] for table in page_soup.findChildren(recursive=False): date = table.caption.span.getText() for i, row in enumerate(table.tbody.findChildren(recursive=False)): cells = row.findChildren(recursive=False) try: vod_id = re.search(r\" . *\\/ (. * ) \", cells[1].a[\" href \"]).group(1) try: best_of = int(re.search(r\" Bo ([ \\d ] * ) \", cells[3].getText()).group(1)) except AttributeError: continue players = [] player = Vod.Player(\" Unknown \", []) for tag in cells[1].a.span.findChildren(recursive=False): if tag.name == \" b \": if len(player.characters) != 0: players.append(player) player = Vod.Player(\" Unknown \", []) player.alias = tag.getText() elif tag.name == \" img \": player.characters.append(guess_character(tag[\" src \"][24:-4])) players.append(player) video_ids, casters = self.scrape_vod_page(vod_id, vod_requests[i]) tournament = re.search(r\" [ ^\\s ]. * [ ^\\s ] \", cells[0].getText()).group() _round = re.search(r\" [ ^\\s ]. * [ ^\\s ] \", cells[4].getText()).group() yield Vod(vod_id, video_ids, date, tournament, players, casters, _round, best_of) except InvalidVideoError as e: if self.verbose: print(e, file=sys.stderr) def scrape(self, pages: Sequence[int] = [], show_progress: bool = False) -> Generator[Vod, None, None]: if not pages: pages = range(self.num_pages - 1) self.num_page_workers = min(self.num_page_workers, len(pages)) request_queue: Queue[Future] = Queue(self.num_page_workers) for i in range(self.num_page_workers): request_queue.put(self.request(f\" { self . base_url } ?page= { pages [ i ]} \")) if show_progress: pages = tqdm(pages, position=1, unit=\" pages \", desc=\" All vods \") for page in pages: vods = self.scrape_page(request_queue.get()) if show_progress: vods = tqdm(vods, position=0, unit=\" vods \", desc=f\" Page { page } \", total=60) for vod in vods: yield vod request_queue.put(self.request(f\" { self . base_url } ?page= { page + self . num_page_workers } \")) @dataclass class URL: video_game: str event: str = \"\" player1: str = \"\" player2: str = \"\" character1: str = \"\" character2: str = \"\" caster1: str = \"\" caster2: str = \"\" def __str__(self) -> str: url = \" https : // vods . co/ \" + self.video_game if self.player1: url += \" / player/ \" + self.player1 if self.player2: url += \" / player2/ \" + self.player2 if self.event: url += \" / event/ \" + self.event if self.character1: url += \" / character/ \" + self.character1 if self.character2: url += \" / character2/ \" + self.character2 if self.caster1: url += \" / caster/ \" + self.character1 if self.caster2: url += \" / caster2/ \" + self . character2 return url Class variables \u00b6 1 URL Instance variables \u00b6 1 base_url 1 num_page_workers 1 num_pages 1 num_workers 1 session 1 verbose Methods \u00b6 request \u00b6 1 2 3 4 def request ( self , url : 'str' ) -> 'Future' View Source def request ( self , url : str ) -> Future : return self . session . get ( url , headers = { \"Accept-Encoding\" : \"gzip\" }) scrape \u00b6 1 2 3 4 5 def scrape ( self , pages : 'Sequence[int]' = [], show_progress : 'bool' = False ) -> 'Generator[Vod, None, None]' View Source def scrape ( self , pages : Sequence [ int ] = [] , show_progress : bool = False ) -> Generator [ Vod, None, None ] : if not pages : pages = range ( self . num_pages - 1 ) self . num_page_workers = min ( self . num_page_workers , len ( pages )) request_queue : Queue [ Future ] = Queue ( self . num_page_workers ) for i in range ( self . num_page_workers ) : request_queue . put ( self . request ( f \"{self.base_url}?page={pages[i]}\" )) if show_progress : pages = tqdm ( pages , position = 1 , unit = \"pages\" , desc = \"All vods\" ) for page in pages : vods = self . scrape_page ( request_queue . get ()) if show_progress : vods = tqdm ( vods , position = 0 , unit = \"vods\" , desc = f \"Page {page}\" , total = 60 ) for vod in vods : yield vod request_queue . put ( self . request ( f \"{self.base_url}?page={page + self.num_page_workers}\" )) scrape_page \u00b6 1 2 3 4 def scrape_page ( self , page_request : 'Future' ) -> 'Generator[Vod, None, None]' View Source def scrape_page ( self , page_request: Future ) -> Generator [ Vod , None , None ] : page_content = page_request . result (). content page_strainer = SoupStrainer ( \"table\" ) page_soup = BeautifulSoup ( page_content , \"lxml\" , parse_only = page_strainer ) vod_requests = [ self . request ( tr . findChild ( \"a\" )[ \"href\" ]) for tr in page_soup . findChildren ( \"tr\" )] for table in page_soup . findChildren ( recursive = False ) : date = table . caption . span . getText () for i , row in enumerate ( table . tbody . findChildren ( recursive = False )) : cells = row . findChildren ( recursive = False ) try : vod_id = re . search ( r \" . *\\/ (. * ) \", cells[1].a[\" href \"]).group(1) try: best_of = int(re.search(r\" Bo ([ \\d ] * ) \", cells[3].getText()).group(1)) except AttributeError: continue players = [] player = Vod.Player(\" Unknown \", []) for tag in cells[1].a.span.findChildren(recursive=False): if tag.name == \" b \": if len(player.characters) != 0: players.append(player) player = Vod.Player(\" Unknown \", []) player.alias = tag.getText() elif tag.name == \" img \": player.characters.append(guess_character(tag[\" src \"][24:-4])) players.append(player) video_ids, casters = self.scrape_vod_page(vod_id, vod_requests[i]) tournament = re.search(r\" [ ^\\s ]. * [ ^\\s ] \", cells[0].getText()).group() _round = re.search(r\" [ ^\\s ]. * [ ^\\s ] \" , cells [ 4 ]. getText ()). group () yield Vod ( vod_id , video_ids , date , tournament , players , casters , _ round , best_of ) except InvalidVideoError as e : if self . verbose : print ( e , file = sys . stderr ) scrape_vod_page \u00b6 1 2 3 4 5 def scrape_vod_page ( self , vod_id : 'str' , vod_request : 'Future' ) -> 'Tuple[List[str], List[Vod.Caster]]' View Source def scrape_vod_page ( self , vod_id : str , vod_request : Future ) -> Tuple [ List[str ] , List [ Vod.Caster ] ]: vod_content = vod_request . result (). content vod_strainer = SoupStrainer ( \"div\" , class_ = \"region-inner clearfix\" ) vod_soup = BeautifulSoup ( vod_content , \"lxml\" , parse_only = vod_strainer ) content = vod_soup . findChild ( recursive = False ) try : video_ids = [ re.search(r\"^([^? ]* ) \", v[\" data - vod \"]).group(1) for v in content.findChildren(\" div \", class_=\" js - video widescreen \", recursive=False) ] if len(video_ids) == 0: raise InvalidVideoError(vod_id) casters = [] casters_tag = content.findChild(\" div \", class_=\" field - items \" ) if casters_tag : casters = [ Vod.Caster(c.getText()) for c in casters_tag.findChildren(recursive=False) ] return ( video_ids , casters ) except KeyError : raise InvalidVideoError ( vod_id )","title":"Scrape"},{"location":"reference/vodscrepe/scrape/#module-vodscrepescrape","text":"None None View Source from __ future__ import annotations import re import sys from concurrent . futures import Future from dataclasses import dataclass from queue import Queue from typing import Generator , List , Sequence , Tuple from bs4 import BeautifulSoup , SoupStrainer from requests_futures . sessions import FuturesSession from tqdm import tqdm from vodscrepe . vod import Vod from . aliases import guess_character from . errors import InvalidVideoError class Scraper : __ slots__ = \"base_url\" , \"num_workers\" , \"num_page_workers\" , \"session\" , \"num_pages\" , \"verbose\" base_url: URL num_workers: int num_page_workers: int session : FuturesSession num_pages: int verbose : bool def __ init__ ( self , video_game: str , event : str = \"\" , player1: str = \"\" , player2: str = \"\" , character1: str = \"\" , character2: str = \"\" , caster1: str = \"\" , caster2: str = \"\" , num_workers: int = 10 , num_page_workers: int = 2 , verbose : bool = False , ) : self . base_url = self . URL ( video_game , event , player1 , player2 , character1 , character2 , caster1 , caster2 ) self . num_workers = num_workers self . num_page_workers = min ( num_page_workers , self . num_workers ) self . session = FuturesSession ( max_workers = self . num_workers ) page_content = self . request ( str ( self . base_url )). result (). content page_soup = BeautifulSoup ( page_content , \"lxml\" ) self . num_pages = 1 last_page_tag = page_soup . findChild ( \"a\" , title= \"Go to last page\" ) if last_page_tag: self . num_pages = int ( re . search ( r \" page= ([ \\d ] + ) \", last_page_tag[\" href \"]).group(1)) self.verbose = verbose def request(self, url: str) -> Future: return self.session.get(url, headers={\" Accept - Encoding \": \" gzip \"}) def scrape_vod_page(self, vod_id: str, vod_request: Future) -> Tuple[List[str], List[Vod.Caster]]: vod_content = vod_request.result().content vod_strainer = SoupStrainer(\" div \", class_=\" region - inner clearfix \") vod_soup = BeautifulSoup(vod_content, \" lxml \", parse_only=vod_strainer) content = vod_soup.findChild(recursive=False) try: video_ids = [ re.search(r\" ^ ([ ^? ] * ) \", v[\" data - vod \"]).group(1) for v in content.findChildren(\" div \", class_=\" js - video widescreen \", recursive=False) ] if len(video_ids) == 0: raise InvalidVideoError(vod_id) casters = [] casters_tag = content.findChild(\" div \", class_=\" field - items \") if casters_tag: casters = [Vod.Caster(c.getText()) for c in casters_tag.findChildren(recursive=False)] return (video_ids, casters) except KeyError: raise InvalidVideoError(vod_id) def scrape_page(self, page_request: Future) -> Generator[Vod, None, None]: page_content = page_request.result().content page_strainer = SoupStrainer(\" table \") page_soup = BeautifulSoup(page_content, \" lxml \", parse_only=page_strainer) vod_requests = [self.request(tr.findChild(\" a \")[\" href \"]) for tr in page_soup.findChildren(\" tr \")] for table in page_soup.findChildren(recursive=False): date = table.caption.span.getText() for i, row in enumerate(table.tbody.findChildren(recursive=False)): cells = row.findChildren(recursive=False) try: vod_id = re.search(r\" . *\\/ (. * ) \", cells[1].a[\" href \"]).group(1) try: best_of = int(re.search(r\" Bo ([ \\d ] * ) \", cells[3].getText()).group(1)) except AttributeError: continue players = [] player = Vod.Player(\" Unknown \", []) for tag in cells[1].a.span.findChildren(recursive=False): if tag.name == \" b \": if len(player.characters) != 0: players.append(player) player = Vod.Player(\" Unknown \", []) player.alias = tag.getText() elif tag.name == \" img \": player.characters.append(guess_character(tag[\" src \"][24:-4])) players.append(player) video_ids, casters = self.scrape_vod_page(vod_id, vod_requests[i]) tournament = re.search(r\" [ ^\\s ]. * [ ^\\s ] \", cells[0].getText()).group() _round = re.search(r\" [ ^\\s ]. * [ ^\\s ] \", cells[4].getText()).group() yield Vod(vod_id, video_ids, date, tournament, players, casters, _round, best_of) except InvalidVideoError as e: if self.verbose: print(e, file=sys.stderr) def scrape(self, pages: Sequence[int] = [], show_progress: bool = False) -> Generator[Vod, None, None]: if not pages: pages = range(self.num_pages - 1) self.num_page_workers = min(self.num_page_workers, len(pages)) request_queue: Queue[Future] = Queue(self.num_page_workers) for i in range(self.num_page_workers): request_queue.put(self.request(f\" { self . base_url } ?page= { pages [ i ]} \")) if show_progress: pages = tqdm(pages, position=1, unit=\" pages \", desc=\" All vods \") for page in pages: vods = self.scrape_page(request_queue.get()) if show_progress: vods = tqdm(vods, position=0, unit=\" vods \", desc=f\" Page { page } \", total=60) for vod in vods: yield vod request_queue.put(self.request(f\" { self . base_url } ?page= { page + self . num_page_workers } \")) @dataclass class URL: video_game: str event: str = \"\" player1: str = \"\" player2: str = \"\" character1: str = \"\" character2: str = \"\" caster1: str = \"\" caster2: str = \"\" def __str__(self) -> str: url = \" https : // vods . co/ \" + self.video_game if self.player1: url += \" / player/ \" + self.player1 if self.player2: url += \" / player2/ \" + self.player2 if self.event: url += \" / event/ \" + self.event if self.character1: url += \" / character/ \" + self.character1 if self.character2: url += \" / character2/ \" + self.character2 if self.caster1: url += \" / caster/ \" + self.character1 if self.caster2: url += \" / caster2/ \" + self . character2 return url","title":"Module vodscrepe.scrape"},{"location":"reference/vodscrepe/scrape/#classes","text":"","title":"Classes"},{"location":"reference/vodscrepe/scrape/#scraper","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Scraper ( video_game : 'str' , event : 'str' = '' , player1 : 'str' = '' , player2 : 'str' = '' , character1 : 'str' = '' , character2 : 'str' = '' , caster1 : 'str' = '' , caster2 : 'str' = '' , num_workers : 'int' = 10 , num_page_workers : 'int' = 2 , verbose : 'bool' = False ) View Source class Scraper : __ slots__ = \"base_url\" , \"num_workers\" , \"num_page_workers\" , \"session\" , \"num_pages\" , \"verbose\" base_url: URL num_workers: int num_page_workers: int session : FuturesSession num_pages: int verbose : bool def __ init__ ( self , video_game: str , event : str = \"\" , player1: str = \"\" , player2: str = \"\" , character1: str = \"\" , character2: str = \"\" , caster1: str = \"\" , caster2: str = \"\" , num_workers: int = 10 , num_page_workers: int = 2 , verbose : bool = False , ) : self . base_url = self . URL ( video_game , event , player1 , player2 , character1 , character2 , caster1 , caster2 ) self . num_workers = num_workers self . num_page_workers = min ( num_page_workers , self . num_workers ) self . session = FuturesSession ( max_workers = self . num_workers ) page_content = self . request ( str ( self . base_url )). result (). content page_soup = BeautifulSoup ( page_content , \"lxml\" ) self . num_pages = 1 last_page_tag = page_soup . findChild ( \"a\" , title= \"Go to last page\" ) if last_page_tag: self . num_pages = int ( re . search ( r \" page= ([ \\d ] + ) \", last_page_tag[\" href \"]).group(1)) self.verbose = verbose def request(self, url: str) -> Future: return self.session.get(url, headers={\" Accept - Encoding \": \" gzip \"}) def scrape_vod_page(self, vod_id: str, vod_request: Future) -> Tuple[List[str], List[Vod.Caster]]: vod_content = vod_request.result().content vod_strainer = SoupStrainer(\" div \", class_=\" region - inner clearfix \") vod_soup = BeautifulSoup(vod_content, \" lxml \", parse_only=vod_strainer) content = vod_soup.findChild(recursive=False) try: video_ids = [ re.search(r\" ^ ([ ^? ] * ) \", v[\" data - vod \"]).group(1) for v in content.findChildren(\" div \", class_=\" js - video widescreen \", recursive=False) ] if len(video_ids) == 0: raise InvalidVideoError(vod_id) casters = [] casters_tag = content.findChild(\" div \", class_=\" field - items \") if casters_tag: casters = [Vod.Caster(c.getText()) for c in casters_tag.findChildren(recursive=False)] return (video_ids, casters) except KeyError: raise InvalidVideoError(vod_id) def scrape_page(self, page_request: Future) -> Generator[Vod, None, None]: page_content = page_request.result().content page_strainer = SoupStrainer(\" table \") page_soup = BeautifulSoup(page_content, \" lxml \", parse_only=page_strainer) vod_requests = [self.request(tr.findChild(\" a \")[\" href \"]) for tr in page_soup.findChildren(\" tr \")] for table in page_soup.findChildren(recursive=False): date = table.caption.span.getText() for i, row in enumerate(table.tbody.findChildren(recursive=False)): cells = row.findChildren(recursive=False) try: vod_id = re.search(r\" . *\\/ (. * ) \", cells[1].a[\" href \"]).group(1) try: best_of = int(re.search(r\" Bo ([ \\d ] * ) \", cells[3].getText()).group(1)) except AttributeError: continue players = [] player = Vod.Player(\" Unknown \", []) for tag in cells[1].a.span.findChildren(recursive=False): if tag.name == \" b \": if len(player.characters) != 0: players.append(player) player = Vod.Player(\" Unknown \", []) player.alias = tag.getText() elif tag.name == \" img \": player.characters.append(guess_character(tag[\" src \"][24:-4])) players.append(player) video_ids, casters = self.scrape_vod_page(vod_id, vod_requests[i]) tournament = re.search(r\" [ ^\\s ]. * [ ^\\s ] \", cells[0].getText()).group() _round = re.search(r\" [ ^\\s ]. * [ ^\\s ] \", cells[4].getText()).group() yield Vod(vod_id, video_ids, date, tournament, players, casters, _round, best_of) except InvalidVideoError as e: if self.verbose: print(e, file=sys.stderr) def scrape(self, pages: Sequence[int] = [], show_progress: bool = False) -> Generator[Vod, None, None]: if not pages: pages = range(self.num_pages - 1) self.num_page_workers = min(self.num_page_workers, len(pages)) request_queue: Queue[Future] = Queue(self.num_page_workers) for i in range(self.num_page_workers): request_queue.put(self.request(f\" { self . base_url } ?page= { pages [ i ]} \")) if show_progress: pages = tqdm(pages, position=1, unit=\" pages \", desc=\" All vods \") for page in pages: vods = self.scrape_page(request_queue.get()) if show_progress: vods = tqdm(vods, position=0, unit=\" vods \", desc=f\" Page { page } \", total=60) for vod in vods: yield vod request_queue.put(self.request(f\" { self . base_url } ?page= { page + self . num_page_workers } \")) @dataclass class URL: video_game: str event: str = \"\" player1: str = \"\" player2: str = \"\" character1: str = \"\" character2: str = \"\" caster1: str = \"\" caster2: str = \"\" def __str__(self) -> str: url = \" https : // vods . co/ \" + self.video_game if self.player1: url += \" / player/ \" + self.player1 if self.player2: url += \" / player2/ \" + self.player2 if self.event: url += \" / event/ \" + self.event if self.character1: url += \" / character/ \" + self.character1 if self.character2: url += \" / character2/ \" + self.character2 if self.caster1: url += \" / caster/ \" + self.character1 if self.caster2: url += \" / caster2/ \" + self . character2 return url","title":"Scraper"},{"location":"reference/vodscrepe/scrape/#class-variables","text":"1 URL","title":"Class variables"},{"location":"reference/vodscrepe/scrape/#instance-variables","text":"1 base_url 1 num_page_workers 1 num_pages 1 num_workers 1 session 1 verbose","title":"Instance variables"},{"location":"reference/vodscrepe/scrape/#methods","text":"","title":"Methods"},{"location":"reference/vodscrepe/scrape/#request","text":"1 2 3 4 def request ( self , url : 'str' ) -> 'Future' View Source def request ( self , url : str ) -> Future : return self . session . get ( url , headers = { \"Accept-Encoding\" : \"gzip\" })","title":"request"},{"location":"reference/vodscrepe/scrape/#scrape","text":"1 2 3 4 5 def scrape ( self , pages : 'Sequence[int]' = [], show_progress : 'bool' = False ) -> 'Generator[Vod, None, None]' View Source def scrape ( self , pages : Sequence [ int ] = [] , show_progress : bool = False ) -> Generator [ Vod, None, None ] : if not pages : pages = range ( self . num_pages - 1 ) self . num_page_workers = min ( self . num_page_workers , len ( pages )) request_queue : Queue [ Future ] = Queue ( self . num_page_workers ) for i in range ( self . num_page_workers ) : request_queue . put ( self . request ( f \"{self.base_url}?page={pages[i]}\" )) if show_progress : pages = tqdm ( pages , position = 1 , unit = \"pages\" , desc = \"All vods\" ) for page in pages : vods = self . scrape_page ( request_queue . get ()) if show_progress : vods = tqdm ( vods , position = 0 , unit = \"vods\" , desc = f \"Page {page}\" , total = 60 ) for vod in vods : yield vod request_queue . put ( self . request ( f \"{self.base_url}?page={page + self.num_page_workers}\" ))","title":"scrape"},{"location":"reference/vodscrepe/scrape/#scrape_page","text":"1 2 3 4 def scrape_page ( self , page_request : 'Future' ) -> 'Generator[Vod, None, None]' View Source def scrape_page ( self , page_request: Future ) -> Generator [ Vod , None , None ] : page_content = page_request . result (). content page_strainer = SoupStrainer ( \"table\" ) page_soup = BeautifulSoup ( page_content , \"lxml\" , parse_only = page_strainer ) vod_requests = [ self . request ( tr . findChild ( \"a\" )[ \"href\" ]) for tr in page_soup . findChildren ( \"tr\" )] for table in page_soup . findChildren ( recursive = False ) : date = table . caption . span . getText () for i , row in enumerate ( table . tbody . findChildren ( recursive = False )) : cells = row . findChildren ( recursive = False ) try : vod_id = re . search ( r \" . *\\/ (. * ) \", cells[1].a[\" href \"]).group(1) try: best_of = int(re.search(r\" Bo ([ \\d ] * ) \", cells[3].getText()).group(1)) except AttributeError: continue players = [] player = Vod.Player(\" Unknown \", []) for tag in cells[1].a.span.findChildren(recursive=False): if tag.name == \" b \": if len(player.characters) != 0: players.append(player) player = Vod.Player(\" Unknown \", []) player.alias = tag.getText() elif tag.name == \" img \": player.characters.append(guess_character(tag[\" src \"][24:-4])) players.append(player) video_ids, casters = self.scrape_vod_page(vod_id, vod_requests[i]) tournament = re.search(r\" [ ^\\s ]. * [ ^\\s ] \", cells[0].getText()).group() _round = re.search(r\" [ ^\\s ]. * [ ^\\s ] \" , cells [ 4 ]. getText ()). group () yield Vod ( vod_id , video_ids , date , tournament , players , casters , _ round , best_of ) except InvalidVideoError as e : if self . verbose : print ( e , file = sys . stderr )","title":"scrape_page"},{"location":"reference/vodscrepe/scrape/#scrape_vod_page","text":"1 2 3 4 5 def scrape_vod_page ( self , vod_id : 'str' , vod_request : 'Future' ) -> 'Tuple[List[str], List[Vod.Caster]]' View Source def scrape_vod_page ( self , vod_id : str , vod_request : Future ) -> Tuple [ List[str ] , List [ Vod.Caster ] ]: vod_content = vod_request . result (). content vod_strainer = SoupStrainer ( \"div\" , class_ = \"region-inner clearfix\" ) vod_soup = BeautifulSoup ( vod_content , \"lxml\" , parse_only = vod_strainer ) content = vod_soup . findChild ( recursive = False ) try : video_ids = [ re.search(r\"^([^? ]* ) \", v[\" data - vod \"]).group(1) for v in content.findChildren(\" div \", class_=\" js - video widescreen \", recursive=False) ] if len(video_ids) == 0: raise InvalidVideoError(vod_id) casters = [] casters_tag = content.findChild(\" div \", class_=\" field - items \" ) if casters_tag : casters = [ Vod.Caster(c.getText()) for c in casters_tag.findChildren(recursive=False) ] return ( video_ids , casters ) except KeyError : raise InvalidVideoError ( vod_id )","title":"scrape_vod_page"},{"location":"reference/vodscrepe/vod/","text":"Module vodscrepe.vod \u00b6 None None View Source from __future__ import annotations from dataclasses import dataclass from typing import List @dataclass class Vod : __slots__ = \"vod_id\" , \"video_ids\" , \"date\" , \"tournament\" , \"players\" , \"casters\" , \"round\" , \"best_of\" vod_id : str video_ids : List [ str ] date : str tournament : str players : List [ Vod . Player ] casters : List [ Vod . Caster ] round : str best_of : int def __str__ ( self ) -> str : date = f \"[ { self . date } ]\" players = \" vs \" . join ( str ( p ) for p in self . players ) best_of = f \"Bo { self . best_of } \" return f \" { date } { self . tournament } - { players } - { self . round } - { best_of } \" @dataclass class Player : __slots__ = \"alias\" , \"characters\" alias : str characters : List [ str ] def __str__ ( self ) -> str : return f \" { self . alias } ( { ',' . join ( self . characters ) } )\" @dataclass class Caster : __slots__ = ( \"alias\" ,) alias : str def __str__ ( self ) -> str : return self . alias Classes \u00b6 Vod \u00b6 1 2 3 4 5 6 7 8 9 10 class Vod ( vod_id : 'str' , video_ids : 'List[str]' , date : 'str' , tournament : 'str' , players : 'List[Vod.Player]' , casters : 'List[Vod.Caster]' , round : 'str' , best_of : 'int' ) View Source class Vod : __slots__ = \"vod_id\" , \"video_ids\" , \"date\" , \"tournament\" , \"players\" , \"casters\" , \"round\" , \"best_of\" vod_id : str video_ids : List [ str ] date : str tournament : str players : List [ Vod.Player ] casters : List [ Vod.Caster ] round : str best_of : int def __str__ ( self ) -> str : date = f \"[{self.date}]\" players = \" vs \" . join ( str ( p ) for p in self . players ) best_of = f \"Bo{self.best_of}\" return f \"{date} {self.tournament} - {players} - {self.round} - {best_of}\" @dataclass class Player : __slots__ = \"alias\" , \"characters\" alias : str characters : List [ str ] def __str__ ( self ) -> str : return f \"{self.alias} ({','.join(self.characters)})\" @dataclass class Caster : __slots__ = ( \"alias\" ,) alias : str def __str__ ( self ) -> str : return self . alias Class variables \u00b6 1 Caster 1 Player Instance variables \u00b6 1 best_of 1 casters 1 date 1 players 1 round 1 tournament 1 video_ids 1 vod_id","title":"Vod"},{"location":"reference/vodscrepe/vod/#module-vodscrepevod","text":"None None View Source from __future__ import annotations from dataclasses import dataclass from typing import List @dataclass class Vod : __slots__ = \"vod_id\" , \"video_ids\" , \"date\" , \"tournament\" , \"players\" , \"casters\" , \"round\" , \"best_of\" vod_id : str video_ids : List [ str ] date : str tournament : str players : List [ Vod . Player ] casters : List [ Vod . Caster ] round : str best_of : int def __str__ ( self ) -> str : date = f \"[ { self . date } ]\" players = \" vs \" . join ( str ( p ) for p in self . players ) best_of = f \"Bo { self . best_of } \" return f \" { date } { self . tournament } - { players } - { self . round } - { best_of } \" @dataclass class Player : __slots__ = \"alias\" , \"characters\" alias : str characters : List [ str ] def __str__ ( self ) -> str : return f \" { self . alias } ( { ',' . join ( self . characters ) } )\" @dataclass class Caster : __slots__ = ( \"alias\" ,) alias : str def __str__ ( self ) -> str : return self . alias","title":"Module vodscrepe.vod"},{"location":"reference/vodscrepe/vod/#classes","text":"","title":"Classes"},{"location":"reference/vodscrepe/vod/#vod","text":"1 2 3 4 5 6 7 8 9 10 class Vod ( vod_id : 'str' , video_ids : 'List[str]' , date : 'str' , tournament : 'str' , players : 'List[Vod.Player]' , casters : 'List[Vod.Caster]' , round : 'str' , best_of : 'int' ) View Source class Vod : __slots__ = \"vod_id\" , \"video_ids\" , \"date\" , \"tournament\" , \"players\" , \"casters\" , \"round\" , \"best_of\" vod_id : str video_ids : List [ str ] date : str tournament : str players : List [ Vod.Player ] casters : List [ Vod.Caster ] round : str best_of : int def __str__ ( self ) -> str : date = f \"[{self.date}]\" players = \" vs \" . join ( str ( p ) for p in self . players ) best_of = f \"Bo{self.best_of}\" return f \"{date} {self.tournament} - {players} - {self.round} - {best_of}\" @dataclass class Player : __slots__ = \"alias\" , \"characters\" alias : str characters : List [ str ] def __str__ ( self ) -> str : return f \"{self.alias} ({','.join(self.characters)})\" @dataclass class Caster : __slots__ = ( \"alias\" ,) alias : str def __str__ ( self ) -> str : return self . alias","title":"Vod"},{"location":"reference/vodscrepe/vod/#class-variables","text":"1 Caster 1 Player","title":"Class variables"},{"location":"reference/vodscrepe/vod/#instance-variables","text":"1 best_of 1 casters 1 date 1 players 1 round 1 tournament 1 video_ids 1 vod_id","title":"Instance variables"}]}